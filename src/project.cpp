#include "simProcess.h"

#include <iostream>
#include <cstdlib>
#include <vector>
#include <string>
#include <charconv>
#include <utility>
#include <bits/stdc++.h>
#include <math.h>
#include <unistd.h>
#include <time.h>
#include <fstream>

/**
 * Generates an integer random number from an exponential distribution.
 * In context, this is used to generate the number of microseconds a process, such as a CPU burst and IO burst time
 * Xander: This doesn't change the seed that's fed into it to my knowledge, which would make every random integer the same.
 *  
 * @param lambda given by user, effects the random algorithm such that lambda^-1 = average random value generated
 * @param randomSeed the seed used to create a random number.  Re-using the seed will regenerate the same random values.
 * @param floor minimum, should be the initial process arrival time
 * @param cieling maximum, should be the number of cpu bursts for the given process
 * @return integer random number generated by the given parameters
 */
// int next_exp(double lambda, int randomSeed, int floor, int cieling){
//     return 3;
// }
int next_exp(double lambda, int cieling){
    double r = drand48();
    double x = -log(r)/lambda;
    if(x > cieling){
        x =next_exp(lambda, cieling);
    }
    return int(x);
    
   

}
void fcfs(std::vector<Process> &processes, int contexttime); // first come first serve
void sjf(std::vector<Process> &processes, int contexttime, double alpha, double lambda); // shortest job first
void srt(std::vector<Process> &processes, int contexttime, double alpha, double lambda); // shortest remaining time
void rr(std::vector<Process> &processes, int contexttime, int tslice); // round robin // double alpha, double lambda, 

int main(int argc, char** argv){
    //INPUT processing
    //sample input: a.out 8 101 0.001 16384 4 0.5 128 > output05-full.txt

    //general
    if (argc != 8){
        std::cerr << "ERROR: Invalid number of inputs. Expected 8 but recieved " << argc << std::endl;
        return 1;
    }

    /**argv[1]: Define n as the number of processes to simulate. Process IDs are assigned in alphabetical order A through Z. Therefore, you will have at most 26 processes to simulate.
    * number of processes to simulate, 0 < n <= 26
    * */
    int n = std::stoi(argv[1]);
    if (n < 0 || n > 26){
        std::cerr << "ERROR: Number of processes to simulate 'n' is of an invalid size: " << argv[2] << std::endl;
        return 1;
    }
    

    //argv[2]: We will use a pseudo-random number generator to determine the interarrival times of CPU bursts. This command-line argument, i.e. seed, serves as the seed for the pseudo random number sequence. To ensure predictability and repeatability, use srand48() withthis given seed before simulating each scheduling algorithm and drand48() to obtain thenext value in the range [0.0, 1.0). For languages that do not have these functions, implementan equivalent 48-bit linear congruential generator, as described in the man page for thesfunctions in C.1
    int inputSeed = std::stoi(argv[2]);
    //TODO: Implement random
   
    //argv[3]: To determine interarrival times, we will use an exponential distribution; therefore,this command-line argument is parameter λ. Remember that 1λ will be the average randomvalue generated, e.g., if λ = 0.01, then the average should be appoximately 100. See theexp-random.c example; and use the formula shown in the code, i.e., -log( r ) / lambda,where log is the natural logarithm.
    double lambda = std::stod(argv[3]); //average of random values can be calculated by 1/lambda

    //argv[4]: For the exponential distribution, this command-line argument represents the upper bound for valid pseudo-random numbers. This threshold is used to avoid values far down thelong tail of the exponential distribution. As an example, if this is set to 3000, all generatedvalues above 3000 should be skipped. For cases in which this value is used in the ceilingfunction (see the next page), be sure the ceiling is still valid according to this upper bound.
    int randomMax = std::stoi(argv[4]); //maximum value of valid random numbers in the distribution
    //Double Check: Int is correct variable for randomMax

    //argv[5]: Define tcs as the time, in milliseconds, that it takes to perform a context switch.Remember that a context switch occurs each time a process leaves the CPU and is replacedby another process. More specifically, the first half of the context switch time (i.e., tcs2) isthe time required to remove the given process from the CPU; the second half of the contextswitch time is the time required to bring the next process in to use the CPU. Therefore,expect tcs to be a positive even integer.
    int csTime = std::stoi(argv[5]); //milliseconds to perfrom a context switch

    //argv[6]: For the SJF and SRT algorithms, since we cannot know the actual CPU bursttimes beforehand, we will rely on estimates determined via exponential averaging. As such,this command-line argument is the constant α. Note that the initial guess for each processis τ0 =1λ. When calculating τ values, use the “ceiling” function for all calculations.
    double alpha = std::stod(argv[6]); //parameter for SRT and SJF CPU burst times

    //argv[7]: For the RR algorithm, define the time slice value, tslice, measured in milliseconds.
    int timeSlice = std::stoi(argv[7]); //time slice value for RR algorithm

    //TODO: #1 Data structure to store CPU and I/O burst times.  Store them in pairs?  the last cpu burst has no I/O burst

    //generate process times, which will be used for each simulation
    //reseed(inputSeed);
     srand48(inputSeed);
    std::vector<Process> processes;
    if (timeSlice > 1){
        timeSlice = 1;
    }
    for (int p = 0; p < n; p++) // p represents process.  P = 0 --> A
    {
        int arrTime = floor(next_exp(lambda, randomMax));
        
        int bCount =  1+drand48()*100;//next_uni(1, 100); //number of CPU bursts, a random integer between 1 and 100
        ;//next_uni(1, 200);; //arrival time in milliseconds.  UNIMPLEMENTED.
        int tau = ceil(1/lambda); //time in milliseconds.  UNIMPLEMENTED. XANDER: I don't know where this variable comes from, suspect Tcs
        // tau =  ceil(1/lambda); --> this should be tau_0
        processes.push_back(Process(arrTime, tau, bCount, char(p+65), alpha));
        std::cout << "Process " << char(p + 'A') << ": arrival time " << arrTime << "ms; tau "
            << tau << "ms; " << bCount << " CPU bursts:" << std::endl;
        //loop through bCount-1 bursts, doing last burst outside loop
        for (int i = 0; i < bCount-1; i++){
            int cpuTime = ceil(1+next_exp(lambda, randomMax));
           
            int ioTime =   10*ceil(1+next_exp(lambda, randomMax));
            processes.back().addTimes(cpuTime, ioTime);
            std::cout << "--> CPU burst " << cpuTime << "ms --> I/O burst " << ioTime << "ms" << std::endl;
        }
        int cpuTime = ceil(1+next_exp(lambda, randomMax));
        processes.back().addTime(cpuTime);
            std::cout << "--> CPU burst " << cpuTime << "ms "<< std::endl;

        
    }

    //loop through each algorithm
    //0 = FCFS, 1 = SJF, 2 = SRT, 3 = RR
    for (int alg = 0; alg < 4; alg++) //TODO: #2 Ienumerator for algorithm?
    {
        std::cout<<std::endl;
        //reseed(inputSeed);
        
        std::string algorithm;
        switch (alg)
        {
        case 0:
            algorithm = "FCFS";
            fcfs(processes, csTime);
            break;
        case 1:
            algorithm = "SJF";
            sjf(processes, csTime, alpha, lambda);
            break;
        case 2:
            algorithm = "SRT";
            break;
        case 3:
            algorithm = "RR";
            break;
        }
        //do algorithm

    }
    


    //OUTPUT
    // Format: Process <A>: arrival time <76>ms; tau <1000>ms; <9001> CPU bursts:
    // Format: --> CPU burst <387>ms --> I/O burst <1190>ms

    // Format: time <t>ms: <event-details> [Q <queue-contents>]
    // Example: time 51476ms: Process B (tau 26ms) started using the CPU for 3ms burst [Q: empty]

}

//comparator function for using find_if
bool compareProcess(Process &p1, char x)
{
    return (p1.getID() == x);
}

//sort function for the processes, where it is sorted by lowest time first
bool compareArrival(std::pair<int, char> p1, std::pair<int, char> p2){
    return (p1.first < p2.first);
}

// sort function based on burst time
bool compareBurst(std::pair<int, char> p1, std::pair<int, char> p2) {
   return (p1.first < p2.first);
}

//adds an event to the event log and resorts it with newest events first
void addevent(std::vector<int>&events, int event){
    //maybe write own sorting function
    events.insert(events.end(), event);
    std::sort(events.begin(),events.end(), std::greater<int>());
}

//switches processes between the different vectors
void switchVector(std::vector<Process>& v1, std::vector<Process>& v2, char name)
{
  std::vector<Process>::iterator it =std::find_if(v1.begin(), v1.end(), std::bind(compareProcess, std::placeholders::_1, name));
  v2.push_back(*it);
  v1.erase(it);
}



int sjfReady(std::vector<Process>& v1, Process p1)
{
    
    for (int i = 0; i<= int(v1.size()); i++){
        if(i == int(v1.size())){
                v1.push_back(p1);
                return 0;
        }
        //std::cout<<"p1.getTau = "<<p1.getTau()<<" v1["<<i<<"],getTau()= "<<v1[i].getTau()<<" and is process "<<p1.getID()<<std::endl;
        if (p1.getTau() < v1[i].getTau()){
            v1.insert(v1.begin()+i, p1);
            return i; 
        }
        else if (p1.getTau() == v1[i].getTau()){
            if(p1.getID() < v1[i].getID()){
                v1.insert(v1.begin()+i, p1);
                return i; 
            }
        }
    }
    return -1;
}

void switchVectorsjf(std::vector<Process>& v2, std::vector<Process>& v1, char name)
{
  std::vector<Process>::iterator it =std::find_if(v2.begin(), v2.end(), std::bind(compareProcess, std::placeholders::_1, name));
  
    for (int i = 0; i<= int(v1.size()); i++){
        if(i == int(v1.size())){
                v1.push_back(*it);
                v2.erase(it);
                return ;
        }
        //std::cout<<"p1.getTau = "<<p1.getTau()<<" v1["<<i<<"],getTau()= "<<v1[i].getTau()<<" and is process "<<p1.getID()<<std::endl;
        if ((*it).getTau() < v1[i].getTau()){
            v1.insert(v1.begin()+i, *it);
            v2.erase(it);
            return ; 
        }
        else if ((*it).getTau() == v1[i].getTau()){
            if((*it).getID() < v1[i].getID()){
                v1.insert(v1.begin()+i, *it);
                v2.erase(it);
                return ; 
            }
        }
    }
    return;
   
  
}
bool checkforduplicates(std::vector<Process>& v1, int currtime){

    for(int i = 0; i <int(v1.size()); i++){
        if(int(v1[i].getNextIO()) <= currtime){
            return true;
        } 
    }
    return false;
}

//formats the readyqueue for output
std::string printQueue(std::vector<Process>& v1)
{
    std::string out = "";
    if (v1.size()== 0){
        out = out.append(" empty");
    }
    else{
        for(int i= 0; i<int(v1.size()); i++){
            out = out.append(" ");
            out +=v1[i].getID();
        }
    }
    out = out.append("]");
    return out;
}

// checks if premption occured
bool rrPrempted(std::vector<Process> readyState, int currtime, char ID, int currIO, int currtslice) {
    if (currtslice < currIO) {
        // no context switch if nothing in queue
        // should switch to next process if queue has more things in it
        if (readyState.size() == 0) {
            std::cout << "time " << currtime << "ms: Time slice expired; no preemption because ready queue is empty [Q: empty]" << std::endl;
        } else {
            std::cout << "time " << currIO << "ms: Time slice expired; process " << ID << " preempted with " << currtime << "remaining " << printQueue(readyState) << std::endl;
            return true;
        }
    }

    return false;
}

// first come first serve
void fcfs(std::vector<Process>& processes, int contexttime) {
    std::ofstream outfile;
    outfile.open("simout.txt", std::ios::app);
    
    //variable declarations
    int currtime = 0;
    bool inprocess = true; //turns false when there are no processes in the ready, running, or waiting state 
    bool inuse = false;
    int n = processes.size(); //the amount of processes
    int totalcputime = 0;
    int contextSwitches = 0;
    int totalwaittime = 0;
    int totalwaits = 0;
    
    std::vector<Process> ioState; //process objects in ioState
    std::vector<Process> readyState; // Process objects in readyState do not reference the same objects as those in the processes argument, it is just a copy
    std::vector<Process> runState;//vector container for holding only one process to keep the same modification methods
    std::vector<Process>::iterator readyit;
    std::vector<Process>::iterator ioit;
  
    //sorts and creates order for initial ready queue for processes
    std::pair<int, char> arrivalarr[n];
    
    // udates arrivalarr to hold all processes
    for(int i = 0; i< n; i++){
        arrivalarr[i].first=processes[i].getArrival();
        arrivalarr[i].second=processes[i].getID();
    }
    std::sort(arrivalarr, arrivalarr+n, compareArrival);
   
    //uses sorted arrival time to begin ready state
    int startsreached = 0;
    std::cout<<"time "<<currtime<<"ms: Simulator started for FCFS [Q:"<<printQueue(readyState)<<std::endl;
    while(inprocess) {
        // begins the process_n
        if(startsreached < n){
            if(currtime >= arrivalarr[startsreached].first){
                ioit =std::find_if(processes.begin(), processes.end(), std::bind(compareProcess, std::placeholders::_1, arrivalarr[startsreached].second));
                readyState.push_back(*ioit);
                startsreached +=1;
                if(currtime<= 999){
                    std::cout<<"time "<<currtime<<"ms: Process "<<readyState[readyState.size()-1].getID()<<" arrived; added to ready queue [Q:"<<printQueue(readyState)<<std::endl;
                }  
                    continue;
            }
        }
        
        // when CPU is not in use
        if (inuse == false){
            // when there is something in readyState queue
            if(readyState.size()!=0){
                totalwaittime += currtime -readyState[0].getWait();
                currtime += contexttime/2;
                
                switchVector(readyState, runState, readyState[0].getID());
                if(currtime <= 999){
                    std::cout<<"time "<<currtime<<"ms: Process "<<runState[0].getID()<<" started using the CPU for "<<runState[0].getCurCPU()<<"ms burst [Q:"<<printQueue(readyState)<<std::endl;
                }
                contextSwitches +=1;
                inuse = true;
                
                runState[0].addIOevent(runState[0].getCurCPU()+currtime);
                continue;
            }
        }
        
        // when CPU is in use
        if(inuse == true) {
            if(currtime >= runState[0].getNextIO()){
                
                // if process has been terminated
                if(runState[0].getLen()-runState[0].getCur() <=1){
                    std::cout<<"time "<<currtime<<"ms: Process "<<runState[0].getID()<<" Terminated [Q:"<<printQueue(readyState)<<std::endl;
                    totalcputime += runState[0].getAvgBurst()+runState[0].getCurCPU();
                    totalwaits +=runState[0].getWaits();
                    runState.erase(runState.begin());
                    inuse = false;
                    
                    currtime +=contexttime/2;
                    continue;
                }

                // output complete CPU burst
                if(currtime<= 999){
                    std::cout<<"time "<<currtime<<"ms: Process "<<runState[0].getID()<<" completed a CPU burst; "<<runState[0].getLen()-runState[0].getCur()-1 <<"bursts to go "<<runState[0].getCurCPU()<<"ms burst [Q:"<<printQueue(readyState)<<std::endl;
                }
                currtime += contexttime/2;
                
                runState[0].addIOevent(runState[0].getCurIO()+currtime);
                
                runState[0].nextP();
                switchVector(runState, ioState, runState[0].getID());
            
                inuse = false;
                
                continue;
            }
        }

        // if there is no more IO, complete IO process 
        if(ioState.size()!= 0){
            for (int i = 0; i< int(ioState.size()); i++){
                if(currtime >= ioState[i].getNextIO()){
                    ioState[i].setWait(currtime);
                    switchVector(ioState, readyState, ioState[i].getID());
                    if(currtime<= 999){
                        std::cout<<"time "<<currtime<<"ms: Process "<<readyState[readyState.size()-1].getID()<<" completed I/O; added to ready queue [Q:"<<printQueue(readyState)<<std::endl;
                    }
                    goto cnt;
                }
            }
            
        }
        
        // simulator ends
        if(ioState.size()==0 && readyState.size()==0 && runState.size()==0 &&startsreached ==n){
            std::cout << "time "<<currtime<<"ms: Simulator ended for FCFS" << std::endl;
            inprocess =false;
            continue;
        }
        
        currtime+=1;
        cnt:;
    }
    double avgBurst = (double)totalcputime/(double)contextSwitches;
    //std::cout<<totalcputime<<" "<<contextSwitches<<" " <<std::setprecision(5)<<avgBurst<<std::endl;
    avgBurst = (ceil(avgBurst*1000) )/1000;
    double avgWait = (double)totalwaittime/(double)totalwaits;
    //std::cout<<totalwaits<<" "<<totalwaittime<<" " <<std::setprecision(5)<<avgWait<<std::endl;
    double cpuUtil =100*(1-((double)(currtime-totalcputime-totalwaittime)/(double)currtime));
    //std::cout<<avgWait<<std::endl;
    outfile << "Algorithm FCFS\n";
    outfile << "-- average CPU burst time: " << std::fixed << std::setprecision(3) << avgBurst << " ms" << std::endl;
    outfile << "-- average wait time: " << std::fixed << std::setprecision(3) << avgWait << " ms" << std::endl;
    outfile << "-- average turnaround time: " << std::fixed << std::setprecision(3) << avgWait + avgBurst + contexttime << " ms" << std::endl;
    outfile << "-- total number of preemptions : 0" << std::endl;
    outfile << "-- CPU utilization: " << std::fixed << std::setprecision(3) << cpuUtil << "%" << std::endl;
    outfile.close();
}

// shortest job first
void sjf(std::vector<Process>& processes, int contexttime, double alpha, double lambda) {
   
    std::ofstream outfile;
    outfile.open("simout.txt", std::ios::app);
    
    //variable declarations
    int currtime = 0;
    bool inprocess = true; //turns false when there are no processes in the ready, running, or waiting state 
    bool inuse =false;
    int n = processes.size(); //the amount of processes
    int totalcputime =0;
    int contextSwitches = 0;
    int totalwaittime = 0;
    int totalwaits = 0;
    bool contextflag = false;
    int contexttimer =0;
    
    std::vector<Process> ioState; //process objects in ioState
    std::vector<Process> readyState; // Process objects in readyState do not reference the same objects as those in the processes argument, it is just a copy
    std::vector<Process> runState;//vector container for holding only one process to keep the same modification methods
    std::vector<Process>::iterator readyit;
    std::vector<Process>::iterator ioit;
  
    //sorts and creates order for initial ready queue for processes
    std::pair<int, char> arrivalarr[n];
    
    
    for(int i = 0; i< n; i++){
        arrivalarr[i].first=processes[i].getArrival();
        arrivalarr[i].second=processes[i].getID();
    }

    // sorts based on expected burst
    std::sort(arrivalarr, arrivalarr+n, compareArrival);
   
    //uses sorted epected burst time to begin ready state
    int startsreached =0;
    std::cout<<"time "<<currtime<<"ms: Simulator started for FCFS [Q:"<<printQueue(readyState)<<std::endl;
    while(inprocess){
        if(contextflag == true){
            contexttimer -=1;
            goto contextswitch;
        }
        
        // when CPU not in use
        if (inuse == false){
            // when there is somehting in the ready queue
            if(readyState.size()!=0){
                totalwaittime += currtime -readyState[0].getWait();
                currtime += floor(contexttime/2);
                
                switchVector(readyState, runState, readyState[0].getID());

                // outputs process time
                if(1000>=currtime){
                    std::cout<<"time "<<currtime<<"ms: Process "<<runState[0].getID()<<" (tau "<<runState[0].getTau()<<") started using the CPU for "<<runState[0].getCurCPU()<<"ms burst [Q:"<<printQueue(readyState)<<std::endl;
                }
                contextSwitches +=1;
                inuse= true;
                
                runState[0].addIOevent(runState[0].getCurCPU()+currtime);
                continue;
            }
        }
        
        // when in-use
        if(inuse == true) {
            // when something can be outputted
            if(currtime >= runState[0].getNextIO()){
                // process has terminated
                if(runState[0].getLen()-runState[0].getCur() <=1){
                    std::cout<<"time "<<currtime<<"ms: Process "<<runState[0].getID()<<" Terminated [Q:"<<printQueue(readyState)<<std::endl;
                    totalcputime += runState[0].getAvgBurst()+runState[0].getCurCPU();
                    totalwaits +=runState[0].getWaits();
                    runState.erase(runState.begin());
                    inuse = false;
                    
                    contextflag = true;
                    contexttimer=contexttime/2;
                    //std::cout<<"time "<<currtime<<"ms: going to contextswitch from emptyprocess"<<std::endl;
                goto contextswitch;
                }
                // process can be outpputed
                if(1000>=currtime){
                    std::cout<<"time "<<currtime<<"ms: Process "<<runState[0].getID()<<" (tau "<<runState[0].getTau()<<") completed a CPU burst; "<<runState[0].getLen()-runState[0].getCur()-1 <<"bursts to go "<<runState[0].getCurCPU()<<"ms burst [Q:"<<printQueue(readyState)<<std::endl;
                    std::cout<<"time "<<currtime<<"ms: Process "<<runState[0].getID()<<" switching out of CPU; will block I/O untill time "<<runState[0].getCurIO()+(currtime+contexttime/2) <<"ms [Q:"<<printQueue(readyState)<<std::endl;
                }
                
                // updates runState for next burst
                runState[0].addIOevent(runState[0].getCurIO()+currtime+contexttime/2);
                runState[0].nextTau();
                runState[0].nextP();
                switchVector(runState, ioState, runState[0].getID());
                
                
                inuse = false;
                
                contextflag = true;
                contexttimer=contexttime/2;
                //std::cout<<"time "<<currtime<<"ms: going to contextswitch from complete burst"<<std::endl;
                goto contextswitch;
                    
            }
        }
        contextswitch:;

        // debugging
        // if(currtime<1000){
        //     std::cout<<"time "<<currtime<<"ms: reached contextswitch"<<std::endl;
        // }

        // when there are no more IO
        if(ioState.size()!= 0){
            for (int i = 0; i< int(ioState.size()); i++){
                if(currtime >= ioState[i].getNextIO()){
                    ioState[i].setWait(currtime);

                    char id = ioState[i].getID();
                    int taul = ioState[i].getTau();
                    switchVectorsjf(ioState, readyState, ioState[i].getID());

                    if(1000>=currtime){
                        std::cout<<"time "<<currtime<<"ms: Process "<<id<<" (tau " <<taul<<") completed I/O; added to ready queue [Q:"<<printQueue(readyState)<<std::endl;
                    }
                    
                    if (checkforduplicates(ioState, currtime) == true){
                        goto contextswitch;
                    }
                    if(contextflag ==true){
                        //std::cout<<"time "<<currtime<<"ms: going to contextswitch from i/ocompletet"<<std::endl;
                        goto contextswitch;
                    }
                    else{
                        goto skip;
                    }
                }
            }
            
            
        }

        // when process begins
        if(startsreached < n){
            if(currtime >= arrivalarr[startsreached].first){
                ioit =std::find_if(processes.begin(), processes.end(), std::bind(compareProcess, std::placeholders::_1, arrivalarr[startsreached].second));
                sjfReady(readyState, *ioit);
                startsreached +=1;
                if(1000>=currtime){
                    //std::cout<<(*ioit).getID()<<std::endl;
                    std::cout<<"time "<<currtime<<"ms: Process "<<(*ioit).getID()<<" arrived; added to ready queue [Q:"<<printQueue(readyState)<<std::endl;
                }
                if(contextflag ==true){
                    goto contextswitch;
                }
                else{
                    goto skip;
                }

            }
        }
        
        // ends process
        if(ioState.size()==0 && readyState.size()==0 && runState.size()==0 &&startsreached ==n){
            std::cout << "time "<<currtime+contexttime/2<<"ms: Simulator ended for FCFS" << std::endl;
            inprocess =false;
            continue;
        }
        
        if(contextflag == true)
        {
            if(contexttimer >0){
                currtime+=1;
                continue; 
            }
            if(contexttimer <=0){
                contextflag = false;
                continue;
            }
        }
        currtime+=1;
        skip:;
    }
    double avgBurst = (double)totalcputime/(double)contextSwitches;
    //std::cout<<totalcputime<<" "<<contextSwitches<<" " <<std::setprecision(5)<<avgBurst<<std::endl;
    avgBurst = (ceil(avgBurst*1000) )/1000;
    double avgWait = (double)totalwaittime/(double)totalwaits;
    //std::cout<<totalwaits<<" "<<totalwaittime<<" " <<std::setprecision(5)<<avgWait<<std::endl;
    double cpuUtil =100*(1-((double)(currtime-totalcputime-totalwaittime)/(double)currtime));
    //std::cout<<avgWait<<std::endl;
    outfile <<"Algorithm FCFS\n";
    outfile<<"-- average CPU burst time: " <<std::fixed<< std::setprecision(3)<<avgBurst<<" ms"<<std::endl;
    outfile<<"-- average wait time: " <<std::fixed<< std::setprecision(3)<<avgWait<<" ms"<<std::endl;
    outfile<<"-- average turnaround time: " <<std::fixed<< std::setprecision(3)<<avgWait+avgBurst+contexttime<<" ms"<<std::endl;
    outfile<<"-- total number of preemptions : 0" <<std::endl;
    outfile<<"-- CPU utilization: " <<std::fixed<< std::setprecision(3)<<cpuUtil<<"%"<<std::endl;
    outfile.close();
}

// shortest remaining time
// adding basic set up for individual algorithms
// add variables as needed
/** SRT simulates the shortest remaining time multithreading algorithm. */
void srt(std::vector<Process> &processes, int contexttime, double alpha, double lambda)
{
    // because of similiarity with SJF, code starts out copied

    std::ofstream outfile;
    outfile.open("simout.txt", std::ios::app);

    // variable declarations
    int currtime = 0;
    bool inprocess = true; // turns false when there are no processes in the ready, running, or waiting state
    bool inuse = false;
    int n = processes.size(); // the amount of processes
    int totalcputime = 0;
    int contextSwitches = 0;
    int totalwaittime = 0;
    int totalwaits = 0;
    bool contextflag = false;
    int preemptions = 0;
    int contexttimer = 0;

    std::vector<Process> ioState;    // process objects in ioState
    std::vector<Process> readyState; // Process objects in readyState do not reference the same objects as those in the processes argument, it is just a copy
    std::vector<Process> runState;   // vector container for holding only one process to keep the same modification methods
    std::vector<Process>::iterator readyit;
    std::vector<Process>::iterator ioit;

    // sorts and creates order for initial ready queue for processes
    std::pair<int, char> arrivalarr[n];

    for (int i = 0; i < n; i++)
    {
        arrivalarr[i].first = processes[i].getArrival();
        arrivalarr[i].second = processes[i].getID();
    }
    std::sort(arrivalarr, arrivalarr + n, compareArrival);

    // uses sorted arrival time to begin ready state
    int startsreached = 0;
    std::cout << "time " << currtime << "ms: Simulator started for FCFS [Q:" << printQueue(readyState) << std::endl;
    while (inprocess) //loop that continues until all queues are empty and the simulation has ended
    {
        if (contextflag == true)
        {
            contexttimer -= 1;
            goto srtcontextswitch;
        }

        if (inuse == false) //not in use, ready for another process
        {
            if (readyState.size() != 0) //at least one process in the ready state
            {
                totalwaittime += currtime - readyState[0].getWait();
                currtime += floor(contexttime / 2);

                switchVector(readyState, runState, readyState[0].getID());
                if (1000 >= currtime)
                {
                    std::cout << "time " << currtime << "ms: Process " << runState[0].getID() << " (tau " << runState[0].getTau() << ") started using the CPU for " << runState[0].getCurCPU() << "ms burst [Q:" << printQueue(readyState) << std::endl;
                }
                contextSwitches += 1;
                inuse = true;

                runState[0].addIOevent(runState[0].getCurCPU() + currtime);
                continue;
            }
        }

        if (inuse == true) //currently in use
        {
            if (currtime >= runState[0].getNextIO()) //earliest IO burst has ended
            {

                if (runState[0].getLen() - runState[0].getCur() <= 1)
                {
                    std::cout << "time " << currtime << "ms: Process " << runState[0].getID() << " Terminated [Q:" << printQueue(readyState) << std::endl;
                    totalcputime += runState[0].getAvgBurst() + runState[0].getCurCPU();
                    totalwaits += runState[0].getWaits();
                    runState.erase(runState.begin());
                    inuse = false;

                    contextflag = true;
                    contexttimer = contexttime / 2;
                    // std::cout<<"time "<<currtime<<"ms: going to contextswitch from emptyprocess"<<std::endl;
                    goto srtcontextswitch;
                } else {
                    //process has not ended, check for preemption
                    int cRem = runState[0].getLen() - runState[0].getCur();
                    int nRem = 1000000; //look at estimated cpu time of the process whose io just finished //TODO: get this correctly
                    if (cRem > nRem) //if new process is quicker, perform a preemption
                    {
                        preemptions++;
                        //put current process at the end of the ready block

                        //delete current instance of process

                        //put new process on current
                        goto srtcontextswitch; //rely on srtcontextswitch to handle switching in this new time, which is the shortest job
                    }
                }
                if (1000 >= currtime)
                {
                    std::cout << "time " << currtime << "ms: Process " << runState[0].getID() << " (tau " << runState[0].getTau() << ") completed a CPU burst; " << runState[0].getLen() - runState[0].getCur() - 1 << "bursts to go " << runState[0].getCurCPU() << "ms burst [Q:" << printQueue(readyState) << std::endl;
                    std::cout << "time " << currtime << "ms: Process " << runState[0].getID() << " switching out of CPU; will block I/O untill time " << runState[0].getCurIO() + (currtime + contexttime / 2) << "ms [Q:" << printQueue(readyState) << std::endl;
                }

                runState[0].addIOevent(runState[0].getCurIO() + currtime + contexttime / 2);
                runState[0].nextTau();
                runState[0].nextP();
                switchVector(runState, ioState, runState[0].getID());

                inuse = false;

                contextflag = true;
                contexttimer = contexttime / 2;
                // std::cout<<"time "<<currtime<<"ms: going to contextswitch from complete burst"<<std::endl;
                goto srtcontextswitch;
            }
        }
    srtcontextswitch:;
        // if(currtime<1000){
        //     std::cout<<"time "<<currtime<<"ms: reached contextswitch"<<std::endl;
        // }
        if (ioState.size() != 0)
        {
            for (int i = 0; i < int(ioState.size()); i++)
            {
                if (currtime >= ioState[i].getNextIO())
                {
                    ioState[i].setWait(currtime);

                    char id = ioState[i].getID();
                    int taul = ioState[i].getTau();
                    switchVectorsjf(ioState, readyState, ioState[i].getID());
                    if (1000 >= currtime)
                    {
                        std::cout << "time " << currtime << "ms: Process " << id << " (tau " << taul << ") completed I/O; added to ready queue [Q:" << printQueue(readyState) << std::endl;
                    }

                    if (checkforduplicates(ioState, currtime) == true)
                    {
                        goto srtcontextswitch;
                    }
                    if (contextflag == true)
                    {
                        // std::cout<<"time "<<currtime<<"ms: going to contextswitch from i/ocompletet"<<std::endl;
                        goto srtcontextswitch;
                    }
                    else
                    {
                        goto srtskip;
                    }
                }
            }
        }

        if (startsreached < n)
        {
            if (currtime >= arrivalarr[startsreached].first)
            {
                ioit = std::find_if(processes.begin(), processes.end(), std::bind(compareProcess, std::placeholders::_1, arrivalarr[startsreached].second));
                sjfReady(readyState, *ioit);
                startsreached += 1;
                if (1000 >= currtime)
                {
                    // std::cout<<(*ioit).getID()<<std::endl;
                    std::cout << "time " << currtime << "ms: Process " << (*ioit).getID() << " arrived; added to ready queue [Q:" << printQueue(readyState) << std::endl;
                }
                if (contextflag == true)
                {
                    goto srtcontextswitch;
                }
                else
                {
                    goto srtskip;
                }
            }
        }

        if (ioState.size() == 0 && readyState.size() == 0 && runState.size() == 0 && startsreached == n)
        {
            std::cout << "time " << currtime + contexttime / 2 << "ms: Simulator ended for FCFS" << std::endl;
            inprocess = false;
            continue;
        }

        if (contextflag == true)
        {
            if (contexttimer > 0)
            {
                currtime += 1;
                continue;
            }
            if (contexttimer <= 0)
            {
                contextflag = false;
                continue;
            }
        }
        currtime += 1;
    srtskip:;
    }
    double avgBurst = (double)totalcputime / (double)contextSwitches;
    // std::cout<<totalcputime<<" "<<contextSwitches<<" " <<std::setprecision(5)<<avgBurst<<std::endl;
    avgBurst = (ceil(avgBurst * 1000)) / 1000;
    double avgWait = (double)totalwaittime / (double)totalwaits;
    // std::cout<<totalwaits<<" "<<totalwaittime<<" " <<std::setprecision(5)<<avgWait<<std::endl;
    double cpuUtil = 100 * (1 - ((double)(currtime - totalcputime - totalwaittime) / (double)currtime));
    // std::cout<<avgWait<<std::endl;
    outfile << "Algorithm FCFS\n";
    outfile << "-- average CPU burst time: " << std::fixed << std::setprecision(3) << avgBurst << " ms" << std::endl;
    outfile << "-- average wait time: " << std::fixed << std::setprecision(3) << avgWait << " ms" << std::endl;
    outfile << "-- average turnaround time: " << std::fixed << std::setprecision(3) << avgWait + avgBurst + contexttime << " ms" << std::endl;
    outfile << "-- total number of preemptions : " << preemptions << std::endl;
    outfile << "-- CPU utilization: " << std::fixed << std::setprecision(3) << cpuUtil << "%" << std::endl;
    outfile.close();
}

// round robin
void rr(std::vector<Process>& processes, int contexttime, int tslice) {
    // std::cout << "beginning of RR process" << std::endl;
    // variable declaration
    int currtime = 0;
    int currtslice = 0; // current slice being used
    bool inprocess = true; // turns false when there are no processes in the ready, running, or waiting state 
    bool inuse = false;
    bool prempted = false;
    int n = processes.size(); // the amount of processes
    int premptions = 0; // keeps track of number of premptions

    std::pair<int, char> wait[n];
    std::vector<Process> ioState; //process objects in ioState
    std::vector<Process> readyState; // Process objects in readyState do not reference the same objects as those in the processes argument, it is just a copy
    std::vector<Process> runState;//vector container for holding only one process to keep the same modification methods
    std::vector<Process>::iterator readyit;
    std::vector<Process>::iterator ioit;
    std::vector<int> eventlog;
    //std::vector<bool> blocked;

    //sorts and creates order for initial ready queue for processes
    std::pair<int, char> arrivalarr[n];
    
    
    for(int i = 0; i< n; i++){
        arrivalarr[i].first=processes[i].getArrival();
        arrivalarr[i].second=processes[i].getID();
        //blocked.push_back(false); 
    }

    // sorts by arrival time
    std::sort(arrivalarr, arrivalarr+n, compareArrival);

    currtslice += tslice; // updates currtslice so it includes first valid section

    //uses burst to begin ready state
    int startsreached = 0;
    while (inprocess) {
        // must add process back into queue if it does not meet timeslice
        if(startsreached < n){
            if(currtime >= arrivalarr[startsreached].first){
                ioit =std::find_if(processes.begin(), processes.end(), std::bind(compareProcess, std::placeholders::_1, arrivalarr[startsreached].second));
                readyState.push_back(*ioit);
                startsreached +=1;
                if(currtime<= 999){
                    std::cout<<"time "<<currtime<<"ms: Process "<<readyState[readyState.size()-1].getID()<<" arrived; added to ready queue [Q:"<<printQueue(readyState)<<std::endl;
                }
                 
                 continue;

            }
        }

        // checks for premption
        prempted = rrPrempted(readyState, currtime, runState[0].getID(), runState[0].getCurIO(), currtslice);

        if (prempted == true) {
            // go to next value
            prempted = false;
            premptions += 1;
            goto cnt;
            // continue;
        }

       // when CPU is not in use
       if (inuse == false){
            
            // if there are more processes stored in queue
            if(readyState.size()!=0){
                totalwaittime += currtime - readyState[0].getWait();
                currtime += contexttime/2;
               
                
               
                switchVector(readyState, runState, readyState[0].getID());
                 if(currtime<= 999){
                    std::cout<<"time "<<currtime<<"ms: Process "<<runState[0].getID()<<" started using the CPU for "<<runState[0].getCurCPU()<<"ms burst [Q:"<<printQueue(readyState)<<std::endl;
                }
                contextSwitches +=1;
                inuse= true;
                
               
                runState[0].addIOevent(runState[0].getCurCPU()+currtime);
                continue;
            }
        }
        
        // when the CPU is being used
        if(inuse == true) {
            // process is printable 
            if(currtime >= runState[0].getNextIO()){
                
                // process terminated and can be removed from queue
                if(runState[0].getLen()-runState[0].getCur() <=1){
                    std::cout<<"time "<<currtime<<"ms: Process "<<runState[0].getID()<<" Terminated [Q:"<<printQueue(readyState)<<std::endl;
                    totalcputime += runState[0].getAvgBurst()+runState[0].getCurCPU();
                    totalwaits +=runState[0].getWaits();
                    runState.erase(runState.begin()); 

                    inuse = false;
                    
                    currtime +=contexttime/2;
                    continue;
                }

                // if its possible to print
                if(currtime <= 999){
                    std::cout<<"time "<<currtime<<"ms: Process "<<runState[0].getID()<<" completed a CPU burst; "<<runState[0].getLen()-runState[0].getCur()-1 <<"bursts to go "<<runState[0].getCurCPU()<<"ms burst [Q:"<<printQueue(readyState)<<std::endl;
                }
                currtime += contexttime/2;
                
                runState[0].addIOevent(runState[0].getCurIO()+currtime);

                // if nextIO for currID is too far, should block until next occurance
                if (runState[0].getNextIO() > currslice + 2 * tslice) {
                    // can use bool[] to check if something is blocked or not
                    //blocked[std::atoi((runState[0].getID()))] = true;
                    std::cout << "time " << currtime << ": Process " << runState[0].getID() << " switching out of CPU; will block on I/O until time " << runState[0].getNextIO() << "ms " << printQueue(readyState) << std::endl;
                } 
                
                runState[0].nextP();
                switchVector(runState, ioState, runState[0].getID());
                
                
                inuse = false;
                
                continue;
            }
        }

        // when there is nothing else to be run for the current process
        if(ioState.size()!= 0){
            for (int i = 0; i< int(ioState.size()); i++){
                if(currtime >= ioState[i].getNextIO()){
                    ioState[i].setWait(currtime);
                    switchVector(ioState, readyState, ioState[i].getID());
                    if(currtime<= 999){
                        std::cout<<"time "<<currtime<<"ms: Process "<<readyState[readyState.size()-1].getID()<<" completed I/O; added to ready queue [Q:"<<printQueue(readyState)<<std::endl;
                    }
                    goto cnt;
                }
            }
            
        }

        // ends entire simulation
        if(ioState.size()==0 && readyState.size()==0 && runState.size()==0 &&startsreached ==n){
            std::cout << "time " << currtime << "ms: Simulator ended for RR" << std::endl;
            inprocess =false;
            continue;
        }
      
        prempted = false;
        currtime+=1;
        cnt:;

        // updates currtslice
        if (currtslice < currtime) {
            currtslice += tslice;
        }
    }

    double avgBurst = (double)totalcputime/(double)contextSwitches;
    //std::cout<<totalcputime<<" "<<contextSwitches<<" " <<std::setprecision(5)<<avgBurst<<std::endl;
    avgBurst = (ceil(avgBurst*1000) )/1000;
    double avgWait = (double)totalwaittime/(double)totalwaits;
    //std::cout<<totalwaits<<" "<<totalwaittime<<" " <<std::setprecision(5)<<avgWait<<std::endl;
    double cpuUtil =100*(1-((double)(currtime-totalcputime-totalwaittime)/(double)currtime));

    outfile <<"Algorithm RR\n";
    outfile<<"-- average CPU burst time: " <<std::fixed<< std::setprecision(3)<<avgBurst<<" ms"<<std::endl;
    outfile<<"-- average wait time: " <<std::fixed<< std::setprecision(3)<<avgWait<<" ms"<<std::endl;
    outfile<<"-- average turnaround time: " <<std::fixed<< std::setprecision(3)<<avgWait+avgBurst+contexttime<<" ms"<<std::endl;
    outfile<<"-- total number of preemptions : "<< premptions <<std::endl;
    outfile<<"-- CPU utilization: " <<std::fixed<< std::setprecision(3)<<cpuUtil<<"%"<<std::endl;
    outfile.close();
}